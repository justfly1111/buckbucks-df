/*
 *  Copyright (C) 2021 Scoopta
 *  This file is part of Root Bar
 *  Root Bar is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Root Bar is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Root Bar.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <fcntl.h>

#include <sys/stat.h>

#include <map.h>
#include <utils.h>
#include <config.h>

#include <gtk/gtk.h>

static const char* arg_names[] = {"player", "fifo", "prev_text", "play_text", "next_text", "show_title", "format", "length"};

struct mpris {
	GDBusProxy* player;
	GDBusProxy* properties;
	GtkLabel* title;
	char* fifo_path;
	char* player_name;
	bool show_title;
	char* format;
	size_t length;
};

struct cmd_info {
	struct mpris* this;
	char* cmd;
};

static void setup_dbus(struct mpris* this);

static gboolean enter(GtkWidget* widget, GdkEvent* event, gpointer data) {
	(void) event;
	(void) data;
	widget = gtk_bin_get_child(GTK_BIN(widget));
	GtkWidget* parent = gtk_widget_get_parent(widget);
	while(parent != NULL) {
		gtk_widget_set_state_flags(parent, GTK_STATE_FLAG_PRELIGHT, TRUE);
		parent = gtk_widget_get_parent(parent);
	}
	gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_PRELIGHT, TRUE);
	return FALSE;
}

static gboolean leave(GtkWidget* widget, GdkEvent* event, gpointer data) {
	(void) event;
	(void) data;
	widget = gtk_bin_get_child(GTK_BIN(widget));
	GtkWidget* parent = gtk_widget_get_parent(widget);
	while(parent != NULL) {
		gtk_widget_set_state_flags(parent, GTK_STATE_FLAG_NORMAL, TRUE);
		parent = gtk_widget_get_parent(parent);
	}
	gtk_widget_set_state_flags(widget, GTK_STATE_FLAG_NORMAL, TRUE);
	return FALSE;
}

static void dbus_signal(GDBusProxy* proxy, gchar* sender, gchar* signal, GVariant* parameters, gpointer data) {
	(void) proxy;
	(void) sender;

	struct mpris* this = data;
	if(strcmp(signal, "PropertiesChanged") == 0) {
		GVariant* name_var = g_variant_get_child_value(parameters, 0);
		const char* name = g_variant_get_string(name_var, NULL);
		if(strcmp(name, "org.mpris.MediaPlayer2.Player") != 0) {
			return;
		}

		GVariant* dict_var = g_variant_get_child_value(parameters, 1);
		GVariantDict dict;
		g_variant_dict_init(&dict, dict_var);

		if(!g_variant_dict_contains(&dict, "Metadata")) {
			g_variant_dict_clear(&dict);
			return;
		}

		GVariant* metadata = g_variant_dict_lookup_value(&dict, "Metadata", G_VARIANT_TYPE_DICTIONARY);
		g_variant_dict_clear(&dict);
		g_variant_dict_init(&dict, metadata);

		GVariant* value = g_variant_dict_lookup_value(&dict, "xesam:title", G_VARIANT_TYPE_STRING);
		const char* title = g_variant_get_string(value, NULL);

		value = g_variant_dict_lookup_value(&dict, "xesam:artist", G_VARIANT_TYPE_ARRAY);
		value = g_variant_get_child_value(value, 0);
		const char* artist = g_variant_get_string(value, NULL);

		char ret[this->length];
		snprintf(ret, this->length, this->format, title, artist);

		gtk_label_set_text(this->title, ret);
		g_variant_dict_clear(&dict);
	}
}

static gboolean go_back(GtkWidget* widget, GdkEvent* event, gpointer data) {
	(void) widget;
	(void) event;
	struct mpris* this = data;

	if(this->player == NULL) {
		setup_dbus(this);
	}
	if(this->player == NULL) {
		return FALSE;
	}

	GVariant* ret = g_dbus_proxy_call_sync(this->player, "Previous", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	if(ret == NULL) {
		setup_dbus(this);
		ret = g_dbus_proxy_call_sync(this->player, "Previous", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	}
	if(ret != NULL) {
		g_variant_unref(ret);
	}
	return FALSE;
}

static gboolean play_pause(GtkWidget* widget, GdkEvent* event, gpointer data) {
	(void) widget;
	(void) event;
	struct mpris* this = data;

	if(this->player == NULL) {
		setup_dbus(this);
	}
	if(this->player == NULL) {
		return FALSE;
	}

	GVariant* ret = g_dbus_proxy_call_sync(this->player, "PlayPause", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	if(ret == NULL) {
		setup_dbus(this);
		ret = g_dbus_proxy_call_sync(this->player, "PlayPause", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	}
	if(ret != NULL) {
		g_variant_unref(ret);
	}
	return FALSE;
}

static gboolean go_forward(GtkWidget* widget, GdkEvent* event, gpointer data) {
	(void) widget;
	(void) event;
	struct mpris* this = data;

	if(this->player == NULL) {
		setup_dbus(this);
	}
	if(this->player == NULL) {
		return FALSE;
	}

	GVariant* ret = g_dbus_proxy_call_sync(this->player, "Next", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	if(ret == NULL) {
		setup_dbus(this);
		ret = g_dbus_proxy_call_sync(this->player, "Next", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	}
	if(ret != NULL) {
		g_variant_unref(ret);
	}
	return FALSE;
}

static gboolean idle_add(gpointer data) {
	struct cmd_info* cmd = data;
	if(strcmp(cmd->cmd, "previous") == 0) {
		go_back(NULL, NULL, cmd->this);
	} else if(strcmp(cmd->cmd, "play/pause") == 0) {
		play_pause(NULL, NULL, cmd->this);
	} else if(strcmp(cmd->cmd, "next") == 0) {
		go_forward(NULL, NULL, cmd->this);
	}
	free(cmd->cmd);
	free(cmd);
	return FALSE;
}

static void* do_fifo(void* data) {
	struct mpris* this = data;

	if(access(this->fifo_path, F_OK) == 0) {
		unlink(this->fifo_path);
	}
	mkfifo(this->fifo_path, 0600);

	while(true) {
		int fd = open(this->fifo_path, O_RDONLY);

		int size = fcntl(fd, **F_GETPIPE_SZ);
		char* buf = malloc(size);
		ssize_t count = read(fd, buf, size);
		*(buf + count) = 0;

		close(fd);

		struct cmd_info* cmd = malloc(sizeof(struct cmd_info));
		cmd->this = this;
		cmd->cmd = buf;
		g_idle_add(idle_add, cmd);
	}
	return NULL;
}

static void setup_player(struct mpris* this, GtkBox* box, const char* plugin_name, const char* prev_text, const char* play_text, const char* next_text) {
	GtkWidget* prev = gtk_label_new(prev_text);
	this->title = GTK_LABEL(gtk_label_new(play_text));
	GtkWidget* next = gtk_label_new(next_text);

	char* prev_name = utils_concat(2, plugin_name, "-prev");
	GtkStyleContext* context = gtk_widget_get_style_context(prev);
	gtk_style_context_add_class(context, plugin_name);
	gtk_widget_set_name(prev, prev_name);
	free(prev_name);

	char* title_name = utils_concat(2, plugin_name, "-title");
	context = gtk_widget_get_style_context(GTK_WIDGET(this->title));
	gtk_style_context_add_class(context, plugin_name);
	gtk_widget_set_name(GTK_WIDGET(this->title), title_name);
	free(title_name);

	char* next_name = utils_concat(2, plugin_name, "-next");
	context = gtk_widget_get_style_context(next);
	gtk_style_context_add_class(context, plugin_name);
	gtk_widget_set_name(next, next_name);
	free(next_name);

	GtkWidget* prev_box = gtk_event_box_new();
	GtkWidget* title_box = gtk_event_box_new();
	GtkWidget* next_box = gtk_event_box_new();

	g_signal_connect(GTK_WIDGET(prev_box), "enter-notify-event", G_CALLBACK(enter), NULL);
	g_signal_connect(GTK_WIDGET(prev_box), "leave-notify-event", G_CALLBACK(leave), NULL);

	g_signal_connect(GTK_WIDGET(title_box), "enter-notify-event", G_CALLBACK(enter), NULL);
	g_signal_connect(GTK_WIDGET(title_box), "leave-notify-event", G_CALLBACK(leave), NULL);

	g_signal_connect(GTK_WIDGET(next_box), "enter-notify-event", G_CALLBACK(enter), NULL);
	g_signal_connect(GTK_WIDGET(next_box), "leave-notify-event", G_CALLBACK(leave), NULL);

	gtk_container_add(GTK_CONTAINER(prev_box), prev);
	gtk_container_add(GTK_CONTAINER(title_box), GTK_WIDGET(this->title));
	gtk_container_add(GTK_CONTAINER(next_box), next);

	g_signal_connect(prev_box, "button-press-event", G_CALLBACK(go_back), this);
	g_signal_connect(title_box, "button-press-event", G_CALLBACK(play_pause), this);
	g_signal_connect(next_box, "button-press-event", G_CALLBACK(go_forward), this);

	gtk_container_add(GTK_CONTAINER(box), prev_box);
	gtk_container_add(GTK_CONTAINER(box), title_box);
	gtk_container_add(GTK_CONTAINER(box), next_box);



}

static void setup_dbus(struct mpris* this) {
	if(this->player != NULL) {
		g_object_unref(this->player);
	}

	if(this->properties != NULL) {
		g_object_unref(this->properties);
	}

	GDBusProxy* proxy = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SESSION, G_DBUS_PROXY_FLAGS_NONE, NULL, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", NULL, NULL);
	if(proxy == NULL) {
		fprintf(stderr, "Failed to connect to dbus\n");
		return;
	}
	GVariant* ret = g_dbus_proxy_call_sync(proxy, "ListNames", NULL, G_DBUS_CALL_FLAGS_NONE, 2000, NULL, NULL);
	g_object_unref(proxy);

	GVariant* names = g_variant_get_child_value(ret, 0);
	for(size_t count = 0; count < g_variant_n_children(names); ++count) {
		GVariant* name = g_variant_get_child_value(names, count);
		const char* name_str = g_variant_get_string(name, NULL);
		if(strstr(name_str, "org.mpris.MediaPlayer2") != NULL) {
			if(strstr(name_str, this->player_name) != NULL) {
				g_variant_unref(ret);

				if(this->show_title) {
					this->properties = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SESSION, G_DBUS_PROXY_FLAGS_NONE, NULL, name_str, "/org/mpris/MediaPlayer2", "org.freedesktop.DBus.Properties", NULL, NULL);
					g_signal_connect(this->properties, "g-signal", G_CALLBACK(dbus_signal), this);
				}

				this->player = g_dbus_proxy_new_for_bus_sync(G_BUS_TYPE_SESSION, G_DBUS_PROXY_FLAGS_NONE, NULL, name_str, "/org/mpris/MediaPlayer2", "org.mpris.MediaPlayer2.Player", NULL, NULL);
				if(this->player == NULL) {
					fprintf(stderr, "Failed to connect to the player\n");
					return;
				}
			}
		}
	}
}

void* rootbar_mpris_init(struct map* props, GtkBox* box) {
	const char* player_name = map_get(props, "player");
	const char* plugin_name = map_get(props, "_plugin");
	const char* fifo_path = map_get(props, "fifo");
	const char* prev_text = config_get(props, "", "prev_text", "<");
	const char* play_text = config_get(props, "", "play_text", "> ||");
	const char* next_text = config_get(props, "", "next_text", ">");

	if(player_name != NULL) {
		struct mpris* this = calloc(1, sizeof(struct mpris));
		this->show_title = strcmp(config_get(props, "", "show_title", "true"), "true") == 0;
		this->format = strdup(config_get(props, "", "format", "%s"));
		this->length = strtol(config_get(props, "", "length", "50"), NULL, 10);

		this->player_name = strdup(player_name);
		setup_dbus(this);

		gtk_widget_set_name(GTK_WIDGET(box), plugin_name);

		setup_player(this, box, plugin_name, prev_text, play_text, next_text);

		if(fifo_path != NULL) {
			this->fifo_path = strdup(fifo_path);

			pthread_t thread;
			pthread_create(&thread, NULL, do_fifo, this);
		}
		return this;
	}
	fprintf(stderr, "No player specified\n");
	return NULL;
}

gboolean rootbar_mpris_is_advanced() {
	return TRUE;
}

const char** rootbar_mpris_get_arg_names() {
	return arg_names;
}

size_t rootbar_mpris_get_arg_count() {
	return sizeof(arg_names) / sizeof(char*);
}
